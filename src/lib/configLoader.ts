import fs from 'fs/promises'
import path from 'path'
import { compileMDX } from 'next-mdx-remote/rsc'
import { PageConfig } from '../configs/pages'
import { storage } from './storage'
import { isValidAlias } from './alias'

// Get environment variables safely
const getSiteUrl = () => {
  try {
    return process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'
  } catch {
    return 'http://localhost:3000'
  }
}

export interface MDXContent {
  config: PageConfig
  source: string
}

// Load config from MDX file with localization support
export async function loadMDXConfig(slug: string, locale?: string): Promise<MDXContent | null> {
  try {
    // First try to load localized version
    if (locale) {
      const localizedPath = path.join(process.cwd(), `src/content/${slug}.${locale}.mdx`)
      try {
        const source = await fs.readFile(localizedPath, 'utf8')
        const { frontmatter, content } = await compileMDX<{ config: PageConfig }>({
          source,
          options: { parseFrontmatter: true },
        })


        // Extract content without frontmatter
        const contentMatch = source.match(/^---\n[\s\S]*?\n---\n([\s\S]*)$/)
        const contentOnly = contentMatch ? contentMatch[1] : source

        return {
          config: frontmatter.config,
          source: contentOnly
        }
      } catch (error) {
        // If localized version not found, try English
        console.log(`Localized MDX not found for ${slug}.${locale}, trying English fallback`)
      }
    }

    // Fallback to English version
    const filePath = path.join(process.cwd(), `src/content/${slug}.en.mdx`)
    const source = await fs.readFile(filePath, 'utf8')

    const { frontmatter, content } = await compileMDX<{ config: PageConfig }>({
      source,
      options: { parseFrontmatter: true },
    })

    // Extract content without frontmatter
    const contentMatch = source.match(/^---\n[\s\S]*?\n---\n([\s\S]*)$/)
    const contentOnly = contentMatch ? contentMatch[1] : source

    return {
      config: frontmatter.config,
      source: contentOnly
    }
  } catch (error) {
    console.error(`Failed to load MDX config for ${slug}:`, error)
    return null
  }
}

// Load config from JSON (for published QR codes)
export async function loadJSONConfig(alias: string): Promise<PageConfig | null> {
  try {
    const storageItem = await storage.get(alias)
    
    if (!storageItem) {
      return null
    }

    // Create config based on published data
    const config: PageConfig = {
      title: storageItem.title || `QR Code - ${alias}`,
      description: storageItem.description || `Scannable QR code generated by Paste2QR`,
      keywords: 'QR code, scannable, generated, Paste2QR',
      heroTitle: storageItem.title || 'QR Code',
      heroSubtitle: storageItem.description || 'Scannable QR code ready to use',
      heroButtonText: 'View QR Code',
      heroGradient: 'from-gray-600 to-gray-800'
    }

    return config
  } catch (error) {
    console.error(`Failed to load JSON config for ${alias}:`, error)
    return null
  }
}

// Universal config loading with localization support
export async function loadPageConfig(slug: string, locale?: string): Promise<{ config: PageConfig; mdxSource?: string; originalText?: string } | null> {
  // First try to load from MDX (for static pages)
  const mdxContent = await loadMDXConfig(slug, locale)
  if (mdxContent) {
    return {
      config: mdxContent.config,
      mdxSource: mdxContent.source
    }
  }

  // If not found in MDX, check if this is a published QR code
  if (isValidAlias(slug)) {
    const jsonConfig = await loadJSONConfig(slug)
    if (jsonConfig) {
      // Get original text from storage
      const storageItem = await storage.get(slug)
      return {
        config: jsonConfig,
        originalText: storageItem?.text || ''
      }
    }
    
    // If no JSON file but alias is valid, generate config from alias
    try {
      const { aliasToText } = await import('./alias')
      const textFromAlias = aliasToText(slug)
      
      // Create config for alias
      const aliasConfig: PageConfig = {
        title: `QR Code: ${textFromAlias.substring(0, 50)}${textFromAlias.length > 50 ? '...' : ''}`,
        description: `QR code for: ${textFromAlias}`,
        keywords: 'qr code, paste to qr, text to qr',
        heroTitle: 'Paste to QR Code',
        heroSubtitle: `QR code for: ${textFromAlias}`,
        heroButtonText: 'Paste & Generate',
        heroGradient: 'from-blue-600 to-blue-800',
        canonicalUrl: `${getSiteUrl()}/qr/${slug}`,
      }
      
      return {
        config: aliasConfig,
        originalText: textFromAlias
      }
    } catch (error) {
      console.error(`Failed to generate config from alias ${slug}:`, error)
      // Fall through to return null
    }
  }

  return null
}
